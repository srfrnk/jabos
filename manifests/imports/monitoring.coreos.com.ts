// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * ServiceMonitor defines monitoring for a set of services.
 *
 * @schema ServiceMonitor
 */
export class ServiceMonitor extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ServiceMonitor"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'monitoring.coreos.com/v1',
    kind: 'ServiceMonitor',
  }

  /**
   * Renders a Kubernetes manifest for "ServiceMonitor".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ServiceMonitorProps): any {
    return {
      ...ServiceMonitor.GVK,
      ...toJson_ServiceMonitorProps(props),
    };
  }

  /**
   * Defines a "ServiceMonitor" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ServiceMonitorProps) {
    super(scope, id, {
      ...ServiceMonitor.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ServiceMonitor.GVK,
      ...toJson_ServiceMonitorProps(resolved),
    };
  }
}

/**
 * ServiceMonitor defines monitoring for a set of services.
 *
 * @schema ServiceMonitor
 */
export interface ServiceMonitorProps {
  /**
   * @schema ServiceMonitor#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * Specification of desired Service selection for target discovery by Prometheus.
   *
   * @schema ServiceMonitor#spec
   */
  readonly spec: ServiceMonitorSpec;

}

/**
 * Converts an object of type 'ServiceMonitorProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceMonitorProps(obj: ServiceMonitorProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ServiceMonitorSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specification of desired Service selection for target discovery by Prometheus.
 *
 * @schema ServiceMonitorSpec
 */
export interface ServiceMonitorSpec {
  /**
   * A list of endpoints allowed as part of this ServiceMonitor.
   *
   * @schema ServiceMonitorSpec#endpoints
   */
  readonly endpoints: ServiceMonitorSpecEndpoints[];

  /**
   * Chooses the label of the Kubernetes `Endpoints`. Its value will be used for the `job`-label's value of the created metrics.
   * Default & fallback value: the name of the respective Kubernetes `Endpoint`.
   *
   * @schema ServiceMonitorSpec#jobLabel
   */
  readonly jobLabel?: string;

  /**
   * Per-scrape limit on number of labels that will be accepted for a sample. Only valid in Prometheus versions 2.27.0 and newer.
   *
   * @schema ServiceMonitorSpec#labelLimit
   */
  readonly labelLimit?: number;

  /**
   * Per-scrape limit on length of labels name that will be accepted for a sample. Only valid in Prometheus versions 2.27.0 and newer.
   *
   * @schema ServiceMonitorSpec#labelNameLengthLimit
   */
  readonly labelNameLengthLimit?: number;

  /**
   * Per-scrape limit on length of labels value that will be accepted for a sample. Only valid in Prometheus versions 2.27.0 and newer.
   *
   * @schema ServiceMonitorSpec#labelValueLengthLimit
   */
  readonly labelValueLengthLimit?: number;

  /**
   * Selector to select which namespaces the Kubernetes Endpoints objects are discovered from.
   *
   * @schema ServiceMonitorSpec#namespaceSelector
   */
  readonly namespaceSelector?: ServiceMonitorSpecNamespaceSelector;

  /**
   * PodTargetLabels transfers labels on the Kubernetes `Pod` onto the created metrics.
   *
   * @schema ServiceMonitorSpec#podTargetLabels
   */
  readonly podTargetLabels?: string[];

  /**
   * SampleLimit defines per-scrape limit on number of scraped samples that will be accepted.
   *
   * @schema ServiceMonitorSpec#sampleLimit
   */
  readonly sampleLimit?: number;

  /**
   * Selector to select Endpoints objects.
   *
   * @schema ServiceMonitorSpec#selector
   */
  readonly selector: ServiceMonitorSpecSelector;

  /**
   * TargetLabels transfers labels from the Kubernetes `Service` onto the created metrics. All labels set in `selector.matchLabels` are automatically transferred.
   *
   * @schema ServiceMonitorSpec#targetLabels
   */
  readonly targetLabels?: string[];

  /**
   * TargetLimit defines a limit on the number of scraped targets that will be accepted.
   *
   * @schema ServiceMonitorSpec#targetLimit
   */
  readonly targetLimit?: number;

}

/**
 * Converts an object of type 'ServiceMonitorSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceMonitorSpec(obj: ServiceMonitorSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'endpoints': obj.endpoints?.map(y => toJson_ServiceMonitorSpecEndpoints(y)),
    'jobLabel': obj.jobLabel,
    'labelLimit': obj.labelLimit,
    'labelNameLengthLimit': obj.labelNameLengthLimit,
    'labelValueLengthLimit': obj.labelValueLengthLimit,
    'namespaceSelector': toJson_ServiceMonitorSpecNamespaceSelector(obj.namespaceSelector),
    'podTargetLabels': obj.podTargetLabels?.map(y => y),
    'sampleLimit': obj.sampleLimit,
    'selector': toJson_ServiceMonitorSpecSelector(obj.selector),
    'targetLabels': obj.targetLabels?.map(y => y),
    'targetLimit': obj.targetLimit,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Endpoint defines a scrapeable endpoint serving Prometheus metrics.
 *
 * @schema ServiceMonitorSpecEndpoints
 */
export interface ServiceMonitorSpecEndpoints {
  /**
   * Authorization section for this endpoint
   *
   * @schema ServiceMonitorSpecEndpoints#authorization
   */
  readonly authorization?: ServiceMonitorSpecEndpointsAuthorization;

  /**
   * BasicAuth allow an endpoint to authenticate over basic authentication More info: https://prometheus.io/docs/operating/configuration/#endpoints
   *
   * @schema ServiceMonitorSpecEndpoints#basicAuth
   */
  readonly basicAuth?: ServiceMonitorSpecEndpointsBasicAuth;

  /**
   * File to read bearer token for scraping targets.
   *
   * @schema ServiceMonitorSpecEndpoints#bearerTokenFile
   */
  readonly bearerTokenFile?: string;

  /**
   * Secret to mount to read bearer token for scraping targets. The secret needs to be in the same namespace as the service monitor and accessible by the Prometheus Operator.
   *
   * @schema ServiceMonitorSpecEndpoints#bearerTokenSecret
   */
  readonly bearerTokenSecret?: ServiceMonitorSpecEndpointsBearerTokenSecret;

  /**
   * HonorLabels chooses the metric's labels on collisions with target labels.
   *
   * @schema ServiceMonitorSpecEndpoints#honorLabels
   */
  readonly honorLabels?: boolean;

  /**
   * HonorTimestamps controls whether Prometheus respects the timestamps present in scraped data.
   *
   * @schema ServiceMonitorSpecEndpoints#honorTimestamps
   */
  readonly honorTimestamps?: boolean;

  /**
   * Interval at which metrics should be scraped
   *
   * @schema ServiceMonitorSpecEndpoints#interval
   */
  readonly interval?: string;

  /**
   * MetricRelabelConfigs to apply to samples before ingestion.
   *
   * @schema ServiceMonitorSpecEndpoints#metricRelabelings
   */
  readonly metricRelabelings?: ServiceMonitorSpecEndpointsMetricRelabelings[];

  /**
   * OAuth2 for the URL. Only valid in Prometheus versions 2.27.0 and newer.
   *
   * @schema ServiceMonitorSpecEndpoints#oauth2
   */
  readonly oauth2?: ServiceMonitorSpecEndpointsOauth2;

  /**
   * Optional HTTP URL parameters
   *
   * @schema ServiceMonitorSpecEndpoints#params
   */
  readonly params?: { [key: string]: string[] };

  /**
   * HTTP path to scrape for metrics.
   *
   * @schema ServiceMonitorSpecEndpoints#path
   */
  readonly path?: string;

  /**
   * Name of the service port this endpoint refers to. Mutually exclusive with targetPort.
   *
   * @schema ServiceMonitorSpecEndpoints#port
   */
  readonly port?: string;

  /**
   * ProxyURL eg http://proxyserver:2195 Directs scrapes to proxy through this endpoint.
   *
   * @schema ServiceMonitorSpecEndpoints#proxyUrl
   */
  readonly proxyUrl?: string;

  /**
   * RelabelConfigs to apply to samples before scraping. Prometheus Operator automatically adds relabelings for a few standard Kubernetes fields and replaces original scrape job name with __tmp_prometheus_job_name. More info: https://prometheus.io/docs/prometheus/latest/configuration/configuration/#relabel_config
   *
   * @schema ServiceMonitorSpecEndpoints#relabelings
   */
  readonly relabelings?: ServiceMonitorSpecEndpointsRelabelings[];

  /**
   * HTTP scheme to use for scraping.
   *
   * @schema ServiceMonitorSpecEndpoints#scheme
   */
  readonly scheme?: string;

  /**
   * Timeout after which the scrape is ended
   *
   * @schema ServiceMonitorSpecEndpoints#scrapeTimeout
   */
  readonly scrapeTimeout?: string;

  /**
   * Name or number of the target port of the Pod behind the Service, the port must be specified with container port property. Mutually exclusive with port.
   *
   * @schema ServiceMonitorSpecEndpoints#targetPort
   */
  readonly targetPort?: ServiceMonitorSpecEndpointsTargetPort;

  /**
   * TLS configuration to use when scraping the endpoint
   *
   * @schema ServiceMonitorSpecEndpoints#tlsConfig
   */
  readonly tlsConfig?: ServiceMonitorSpecEndpointsTlsConfig;

}

/**
 * Converts an object of type 'ServiceMonitorSpecEndpoints' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceMonitorSpecEndpoints(obj: ServiceMonitorSpecEndpoints | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'authorization': toJson_ServiceMonitorSpecEndpointsAuthorization(obj.authorization),
    'basicAuth': toJson_ServiceMonitorSpecEndpointsBasicAuth(obj.basicAuth),
    'bearerTokenFile': obj.bearerTokenFile,
    'bearerTokenSecret': toJson_ServiceMonitorSpecEndpointsBearerTokenSecret(obj.bearerTokenSecret),
    'honorLabels': obj.honorLabels,
    'honorTimestamps': obj.honorTimestamps,
    'interval': obj.interval,
    'metricRelabelings': obj.metricRelabelings?.map(y => toJson_ServiceMonitorSpecEndpointsMetricRelabelings(y)),
    'oauth2': toJson_ServiceMonitorSpecEndpointsOauth2(obj.oauth2),
    'params': ((obj.params) === undefined) ? undefined : (Object.entries(obj.params).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.map(y => y) }), {})),
    'path': obj.path,
    'port': obj.port,
    'proxyUrl': obj.proxyUrl,
    'relabelings': obj.relabelings?.map(y => toJson_ServiceMonitorSpecEndpointsRelabelings(y)),
    'scheme': obj.scheme,
    'scrapeTimeout': obj.scrapeTimeout,
    'targetPort': obj.targetPort?.value,
    'tlsConfig': toJson_ServiceMonitorSpecEndpointsTlsConfig(obj.tlsConfig),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector to select which namespaces the Kubernetes Endpoints objects are discovered from.
 *
 * @schema ServiceMonitorSpecNamespaceSelector
 */
export interface ServiceMonitorSpecNamespaceSelector {
  /**
   * Boolean describing whether all namespaces are selected in contrast to a list restricting them.
   *
   * @schema ServiceMonitorSpecNamespaceSelector#any
   */
  readonly any?: boolean;

  /**
   * List of namespace names.
   *
   * @schema ServiceMonitorSpecNamespaceSelector#matchNames
   */
  readonly matchNames?: string[];

}

/**
 * Converts an object of type 'ServiceMonitorSpecNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceMonitorSpecNamespaceSelector(obj: ServiceMonitorSpecNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'any': obj.any,
    'matchNames': obj.matchNames?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector to select Endpoints objects.
 *
 * @schema ServiceMonitorSpecSelector
 */
export interface ServiceMonitorSpecSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ServiceMonitorSpecSelector#matchExpressions
   */
  readonly matchExpressions?: ServiceMonitorSpecSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ServiceMonitorSpecSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'ServiceMonitorSpecSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceMonitorSpecSelector(obj: ServiceMonitorSpecSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_ServiceMonitorSpecSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Authorization section for this endpoint
 *
 * @schema ServiceMonitorSpecEndpointsAuthorization
 */
export interface ServiceMonitorSpecEndpointsAuthorization {
  /**
   * The secret's key that contains the credentials of the request
   *
   * @schema ServiceMonitorSpecEndpointsAuthorization#credentials
   */
  readonly credentials?: ServiceMonitorSpecEndpointsAuthorizationCredentials;

  /**
   * Set the authentication type. Defaults to Bearer, Basic will cause an error
   *
   * @default Bearer, Basic will cause an error
   * @schema ServiceMonitorSpecEndpointsAuthorization#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ServiceMonitorSpecEndpointsAuthorization' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceMonitorSpecEndpointsAuthorization(obj: ServiceMonitorSpecEndpointsAuthorization | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'credentials': toJson_ServiceMonitorSpecEndpointsAuthorizationCredentials(obj.credentials),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * BasicAuth allow an endpoint to authenticate over basic authentication More info: https://prometheus.io/docs/operating/configuration/#endpoints
 *
 * @schema ServiceMonitorSpecEndpointsBasicAuth
 */
export interface ServiceMonitorSpecEndpointsBasicAuth {
  /**
   * The secret in the service monitor namespace that contains the password for authentication.
   *
   * @schema ServiceMonitorSpecEndpointsBasicAuth#password
   */
  readonly password?: ServiceMonitorSpecEndpointsBasicAuthPassword;

  /**
   * The secret in the service monitor namespace that contains the username for authentication.
   *
   * @schema ServiceMonitorSpecEndpointsBasicAuth#username
   */
  readonly username?: ServiceMonitorSpecEndpointsBasicAuthUsername;

}

/**
 * Converts an object of type 'ServiceMonitorSpecEndpointsBasicAuth' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceMonitorSpecEndpointsBasicAuth(obj: ServiceMonitorSpecEndpointsBasicAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'password': toJson_ServiceMonitorSpecEndpointsBasicAuthPassword(obj.password),
    'username': toJson_ServiceMonitorSpecEndpointsBasicAuthUsername(obj.username),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Secret to mount to read bearer token for scraping targets. The secret needs to be in the same namespace as the service monitor and accessible by the Prometheus Operator.
 *
 * @schema ServiceMonitorSpecEndpointsBearerTokenSecret
 */
export interface ServiceMonitorSpecEndpointsBearerTokenSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ServiceMonitorSpecEndpointsBearerTokenSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ServiceMonitorSpecEndpointsBearerTokenSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ServiceMonitorSpecEndpointsBearerTokenSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ServiceMonitorSpecEndpointsBearerTokenSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceMonitorSpecEndpointsBearerTokenSecret(obj: ServiceMonitorSpecEndpointsBearerTokenSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RelabelConfig allows dynamic rewriting of the label set, being applied to samples before ingestion. It defines `<metric_relabel_configs>`-section of Prometheus configuration. More info: https://prometheus.io/docs/prometheus/latest/configuration/configuration/#metric_relabel_configs
 *
 * @schema ServiceMonitorSpecEndpointsMetricRelabelings
 */
export interface ServiceMonitorSpecEndpointsMetricRelabelings {
  /**
   * Action to perform based on regex matching. Default is 'replace'
   *
   * @default replace'
   * @schema ServiceMonitorSpecEndpointsMetricRelabelings#action
   */
  readonly action?: ServiceMonitorSpecEndpointsMetricRelabelingsAction;

  /**
   * Modulus to take of the hash of the source label values.
   *
   * @schema ServiceMonitorSpecEndpointsMetricRelabelings#modulus
   */
  readonly modulus?: number;

  /**
   * Regular expression against which the extracted value is matched. Default is '(.*)'
   *
   * @default '
   * @schema ServiceMonitorSpecEndpointsMetricRelabelings#regex
   */
  readonly regex?: string;

  /**
   * Replacement value against which a regex replace is performed if the regular expression matches. Regex capture groups are available. Default is '$1'
   *
   * @default 1'
   * @schema ServiceMonitorSpecEndpointsMetricRelabelings#replacement
   */
  readonly replacement?: string;

  /**
   * Separator placed between concatenated source label values. default is ';'.
   *
   * @schema ServiceMonitorSpecEndpointsMetricRelabelings#separator
   */
  readonly separator?: string;

  /**
   * The source labels select values from existing labels. Their content is concatenated using the configured separator and matched against the configured regular expression for the replace, keep, and drop actions.
   *
   * @schema ServiceMonitorSpecEndpointsMetricRelabelings#sourceLabels
   */
  readonly sourceLabels?: string[];

  /**
   * Label to which the resulting value is written in a replace action. It is mandatory for replace actions. Regex capture groups are available.
   *
   * @schema ServiceMonitorSpecEndpointsMetricRelabelings#targetLabel
   */
  readonly targetLabel?: string;

}

/**
 * Converts an object of type 'ServiceMonitorSpecEndpointsMetricRelabelings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceMonitorSpecEndpointsMetricRelabelings(obj: ServiceMonitorSpecEndpointsMetricRelabelings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'action': obj.action,
    'modulus': obj.modulus,
    'regex': obj.regex,
    'replacement': obj.replacement,
    'separator': obj.separator,
    'sourceLabels': obj.sourceLabels?.map(y => y),
    'targetLabel': obj.targetLabel,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * OAuth2 for the URL. Only valid in Prometheus versions 2.27.0 and newer.
 *
 * @schema ServiceMonitorSpecEndpointsOauth2
 */
export interface ServiceMonitorSpecEndpointsOauth2 {
  /**
   * The secret or configmap containing the OAuth2 client id
   *
   * @schema ServiceMonitorSpecEndpointsOauth2#clientId
   */
  readonly clientId: ServiceMonitorSpecEndpointsOauth2ClientId;

  /**
   * The secret containing the OAuth2 client secret
   *
   * @schema ServiceMonitorSpecEndpointsOauth2#clientSecret
   */
  readonly clientSecret: ServiceMonitorSpecEndpointsOauth2ClientSecret;

  /**
   * Parameters to append to the token URL
   *
   * @schema ServiceMonitorSpecEndpointsOauth2#endpointParams
   */
  readonly endpointParams?: { [key: string]: string };

  /**
   * OAuth2 scopes used for the token request
   *
   * @schema ServiceMonitorSpecEndpointsOauth2#scopes
   */
  readonly scopes?: string[];

  /**
   * The URL to fetch the token from
   *
   * @schema ServiceMonitorSpecEndpointsOauth2#tokenUrl
   */
  readonly tokenUrl: string;

}

/**
 * Converts an object of type 'ServiceMonitorSpecEndpointsOauth2' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceMonitorSpecEndpointsOauth2(obj: ServiceMonitorSpecEndpointsOauth2 | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clientId': toJson_ServiceMonitorSpecEndpointsOauth2ClientId(obj.clientId),
    'clientSecret': toJson_ServiceMonitorSpecEndpointsOauth2ClientSecret(obj.clientSecret),
    'endpointParams': ((obj.endpointParams) === undefined) ? undefined : (Object.entries(obj.endpointParams).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'scopes': obj.scopes?.map(y => y),
    'tokenUrl': obj.tokenUrl,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RelabelConfig allows dynamic rewriting of the label set, being applied to samples before ingestion. It defines `<metric_relabel_configs>`-section of Prometheus configuration. More info: https://prometheus.io/docs/prometheus/latest/configuration/configuration/#metric_relabel_configs
 *
 * @schema ServiceMonitorSpecEndpointsRelabelings
 */
export interface ServiceMonitorSpecEndpointsRelabelings {
  /**
   * Action to perform based on regex matching. Default is 'replace'
   *
   * @default replace'
   * @schema ServiceMonitorSpecEndpointsRelabelings#action
   */
  readonly action?: ServiceMonitorSpecEndpointsRelabelingsAction;

  /**
   * Modulus to take of the hash of the source label values.
   *
   * @schema ServiceMonitorSpecEndpointsRelabelings#modulus
   */
  readonly modulus?: number;

  /**
   * Regular expression against which the extracted value is matched. Default is '(.*)'
   *
   * @default '
   * @schema ServiceMonitorSpecEndpointsRelabelings#regex
   */
  readonly regex?: string;

  /**
   * Replacement value against which a regex replace is performed if the regular expression matches. Regex capture groups are available. Default is '$1'
   *
   * @default 1'
   * @schema ServiceMonitorSpecEndpointsRelabelings#replacement
   */
  readonly replacement?: string;

  /**
   * Separator placed between concatenated source label values. default is ';'.
   *
   * @schema ServiceMonitorSpecEndpointsRelabelings#separator
   */
  readonly separator?: string;

  /**
   * The source labels select values from existing labels. Their content is concatenated using the configured separator and matched against the configured regular expression for the replace, keep, and drop actions.
   *
   * @schema ServiceMonitorSpecEndpointsRelabelings#sourceLabels
   */
  readonly sourceLabels?: string[];

  /**
   * Label to which the resulting value is written in a replace action. It is mandatory for replace actions. Regex capture groups are available.
   *
   * @schema ServiceMonitorSpecEndpointsRelabelings#targetLabel
   */
  readonly targetLabel?: string;

}

/**
 * Converts an object of type 'ServiceMonitorSpecEndpointsRelabelings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceMonitorSpecEndpointsRelabelings(obj: ServiceMonitorSpecEndpointsRelabelings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'action': obj.action,
    'modulus': obj.modulus,
    'regex': obj.regex,
    'replacement': obj.replacement,
    'separator': obj.separator,
    'sourceLabels': obj.sourceLabels?.map(y => y),
    'targetLabel': obj.targetLabel,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Name or number of the target port of the Pod behind the Service, the port must be specified with container port property. Mutually exclusive with port.
 *
 * @schema ServiceMonitorSpecEndpointsTargetPort
 */
export class ServiceMonitorSpecEndpointsTargetPort {
  public static fromNumber(value: number): ServiceMonitorSpecEndpointsTargetPort {
    return new ServiceMonitorSpecEndpointsTargetPort(value);
  }
  public static fromString(value: string): ServiceMonitorSpecEndpointsTargetPort {
    return new ServiceMonitorSpecEndpointsTargetPort(value);
  }
  private constructor(public readonly value: any) {
  }
}

/**
 * TLS configuration to use when scraping the endpoint
 *
 * @schema ServiceMonitorSpecEndpointsTlsConfig
 */
export interface ServiceMonitorSpecEndpointsTlsConfig {
  /**
   * Struct containing the CA cert to use for the targets.
   *
   * @schema ServiceMonitorSpecEndpointsTlsConfig#ca
   */
  readonly ca?: ServiceMonitorSpecEndpointsTlsConfigCa;

  /**
   * Path to the CA cert in the Prometheus container to use for the targets.
   *
   * @schema ServiceMonitorSpecEndpointsTlsConfig#caFile
   */
  readonly caFile?: string;

  /**
   * Struct containing the client cert file for the targets.
   *
   * @schema ServiceMonitorSpecEndpointsTlsConfig#cert
   */
  readonly cert?: ServiceMonitorSpecEndpointsTlsConfigCert;

  /**
   * Path to the client cert file in the Prometheus container for the targets.
   *
   * @schema ServiceMonitorSpecEndpointsTlsConfig#certFile
   */
  readonly certFile?: string;

  /**
   * Disable target certificate validation.
   *
   * @schema ServiceMonitorSpecEndpointsTlsConfig#insecureSkipVerify
   */
  readonly insecureSkipVerify?: boolean;

  /**
   * Path to the client key file in the Prometheus container for the targets.
   *
   * @schema ServiceMonitorSpecEndpointsTlsConfig#keyFile
   */
  readonly keyFile?: string;

  /**
   * Secret containing the client key file for the targets.
   *
   * @schema ServiceMonitorSpecEndpointsTlsConfig#keySecret
   */
  readonly keySecret?: ServiceMonitorSpecEndpointsTlsConfigKeySecret;

  /**
   * Used to verify the hostname for the targets.
   *
   * @schema ServiceMonitorSpecEndpointsTlsConfig#serverName
   */
  readonly serverName?: string;

}

/**
 * Converts an object of type 'ServiceMonitorSpecEndpointsTlsConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceMonitorSpecEndpointsTlsConfig(obj: ServiceMonitorSpecEndpointsTlsConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ca': toJson_ServiceMonitorSpecEndpointsTlsConfigCa(obj.ca),
    'caFile': obj.caFile,
    'cert': toJson_ServiceMonitorSpecEndpointsTlsConfigCert(obj.cert),
    'certFile': obj.certFile,
    'insecureSkipVerify': obj.insecureSkipVerify,
    'keyFile': obj.keyFile,
    'keySecret': toJson_ServiceMonitorSpecEndpointsTlsConfigKeySecret(obj.keySecret),
    'serverName': obj.serverName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema ServiceMonitorSpecSelectorMatchExpressions
 */
export interface ServiceMonitorSpecSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ServiceMonitorSpecSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ServiceMonitorSpecSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema ServiceMonitorSpecSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'ServiceMonitorSpecSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceMonitorSpecSelectorMatchExpressions(obj: ServiceMonitorSpecSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The secret's key that contains the credentials of the request
 *
 * @schema ServiceMonitorSpecEndpointsAuthorizationCredentials
 */
export interface ServiceMonitorSpecEndpointsAuthorizationCredentials {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ServiceMonitorSpecEndpointsAuthorizationCredentials#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ServiceMonitorSpecEndpointsAuthorizationCredentials#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ServiceMonitorSpecEndpointsAuthorizationCredentials#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ServiceMonitorSpecEndpointsAuthorizationCredentials' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceMonitorSpecEndpointsAuthorizationCredentials(obj: ServiceMonitorSpecEndpointsAuthorizationCredentials | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The secret in the service monitor namespace that contains the password for authentication.
 *
 * @schema ServiceMonitorSpecEndpointsBasicAuthPassword
 */
export interface ServiceMonitorSpecEndpointsBasicAuthPassword {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ServiceMonitorSpecEndpointsBasicAuthPassword#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ServiceMonitorSpecEndpointsBasicAuthPassword#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ServiceMonitorSpecEndpointsBasicAuthPassword#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ServiceMonitorSpecEndpointsBasicAuthPassword' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceMonitorSpecEndpointsBasicAuthPassword(obj: ServiceMonitorSpecEndpointsBasicAuthPassword | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The secret in the service monitor namespace that contains the username for authentication.
 *
 * @schema ServiceMonitorSpecEndpointsBasicAuthUsername
 */
export interface ServiceMonitorSpecEndpointsBasicAuthUsername {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ServiceMonitorSpecEndpointsBasicAuthUsername#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ServiceMonitorSpecEndpointsBasicAuthUsername#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ServiceMonitorSpecEndpointsBasicAuthUsername#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ServiceMonitorSpecEndpointsBasicAuthUsername' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceMonitorSpecEndpointsBasicAuthUsername(obj: ServiceMonitorSpecEndpointsBasicAuthUsername | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Action to perform based on regex matching. Default is 'replace'
 *
 * @default replace'
 * @schema ServiceMonitorSpecEndpointsMetricRelabelingsAction
 */
export enum ServiceMonitorSpecEndpointsMetricRelabelingsAction {
  /** replace */
  REPLACE = 'replace',
  /** keep */
  KEEP = 'keep',
  /** drop */
  DROP = 'drop',
  /** hashmod */
  HASHMOD = 'hashmod',
  /** labelmap */
  LABELMAP = 'labelmap',
  /** labeldrop */
  LABELDROP = 'labeldrop',
  /** labelkeep */
  LABELKEEP = 'labelkeep',
}

/**
 * The secret or configmap containing the OAuth2 client id
 *
 * @schema ServiceMonitorSpecEndpointsOauth2ClientId
 */
export interface ServiceMonitorSpecEndpointsOauth2ClientId {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema ServiceMonitorSpecEndpointsOauth2ClientId#configMap
   */
  readonly configMap?: ServiceMonitorSpecEndpointsOauth2ClientIdConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema ServiceMonitorSpecEndpointsOauth2ClientId#secret
   */
  readonly secret?: ServiceMonitorSpecEndpointsOauth2ClientIdSecret;

}

/**
 * Converts an object of type 'ServiceMonitorSpecEndpointsOauth2ClientId' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceMonitorSpecEndpointsOauth2ClientId(obj: ServiceMonitorSpecEndpointsOauth2ClientId | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_ServiceMonitorSpecEndpointsOauth2ClientIdConfigMap(obj.configMap),
    'secret': toJson_ServiceMonitorSpecEndpointsOauth2ClientIdSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The secret containing the OAuth2 client secret
 *
 * @schema ServiceMonitorSpecEndpointsOauth2ClientSecret
 */
export interface ServiceMonitorSpecEndpointsOauth2ClientSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ServiceMonitorSpecEndpointsOauth2ClientSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ServiceMonitorSpecEndpointsOauth2ClientSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ServiceMonitorSpecEndpointsOauth2ClientSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ServiceMonitorSpecEndpointsOauth2ClientSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceMonitorSpecEndpointsOauth2ClientSecret(obj: ServiceMonitorSpecEndpointsOauth2ClientSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Action to perform based on regex matching. Default is 'replace'
 *
 * @default replace'
 * @schema ServiceMonitorSpecEndpointsRelabelingsAction
 */
export enum ServiceMonitorSpecEndpointsRelabelingsAction {
  /** replace */
  REPLACE = 'replace',
  /** keep */
  KEEP = 'keep',
  /** drop */
  DROP = 'drop',
  /** hashmod */
  HASHMOD = 'hashmod',
  /** labelmap */
  LABELMAP = 'labelmap',
  /** labeldrop */
  LABELDROP = 'labeldrop',
  /** labelkeep */
  LABELKEEP = 'labelkeep',
}

/**
 * Struct containing the CA cert to use for the targets.
 *
 * @schema ServiceMonitorSpecEndpointsTlsConfigCa
 */
export interface ServiceMonitorSpecEndpointsTlsConfigCa {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema ServiceMonitorSpecEndpointsTlsConfigCa#configMap
   */
  readonly configMap?: ServiceMonitorSpecEndpointsTlsConfigCaConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema ServiceMonitorSpecEndpointsTlsConfigCa#secret
   */
  readonly secret?: ServiceMonitorSpecEndpointsTlsConfigCaSecret;

}

/**
 * Converts an object of type 'ServiceMonitorSpecEndpointsTlsConfigCa' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceMonitorSpecEndpointsTlsConfigCa(obj: ServiceMonitorSpecEndpointsTlsConfigCa | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_ServiceMonitorSpecEndpointsTlsConfigCaConfigMap(obj.configMap),
    'secret': toJson_ServiceMonitorSpecEndpointsTlsConfigCaSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Struct containing the client cert file for the targets.
 *
 * @schema ServiceMonitorSpecEndpointsTlsConfigCert
 */
export interface ServiceMonitorSpecEndpointsTlsConfigCert {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema ServiceMonitorSpecEndpointsTlsConfigCert#configMap
   */
  readonly configMap?: ServiceMonitorSpecEndpointsTlsConfigCertConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema ServiceMonitorSpecEndpointsTlsConfigCert#secret
   */
  readonly secret?: ServiceMonitorSpecEndpointsTlsConfigCertSecret;

}

/**
 * Converts an object of type 'ServiceMonitorSpecEndpointsTlsConfigCert' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceMonitorSpecEndpointsTlsConfigCert(obj: ServiceMonitorSpecEndpointsTlsConfigCert | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_ServiceMonitorSpecEndpointsTlsConfigCertConfigMap(obj.configMap),
    'secret': toJson_ServiceMonitorSpecEndpointsTlsConfigCertSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing the client key file for the targets.
 *
 * @schema ServiceMonitorSpecEndpointsTlsConfigKeySecret
 */
export interface ServiceMonitorSpecEndpointsTlsConfigKeySecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ServiceMonitorSpecEndpointsTlsConfigKeySecret#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ServiceMonitorSpecEndpointsTlsConfigKeySecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ServiceMonitorSpecEndpointsTlsConfigKeySecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ServiceMonitorSpecEndpointsTlsConfigKeySecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceMonitorSpecEndpointsTlsConfigKeySecret(obj: ServiceMonitorSpecEndpointsTlsConfigKeySecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema ServiceMonitorSpecEndpointsOauth2ClientIdConfigMap
 */
export interface ServiceMonitorSpecEndpointsOauth2ClientIdConfigMap {
  /**
   * The key to select.
   *
   * @schema ServiceMonitorSpecEndpointsOauth2ClientIdConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ServiceMonitorSpecEndpointsOauth2ClientIdConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema ServiceMonitorSpecEndpointsOauth2ClientIdConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ServiceMonitorSpecEndpointsOauth2ClientIdConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceMonitorSpecEndpointsOauth2ClientIdConfigMap(obj: ServiceMonitorSpecEndpointsOauth2ClientIdConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema ServiceMonitorSpecEndpointsOauth2ClientIdSecret
 */
export interface ServiceMonitorSpecEndpointsOauth2ClientIdSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ServiceMonitorSpecEndpointsOauth2ClientIdSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ServiceMonitorSpecEndpointsOauth2ClientIdSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ServiceMonitorSpecEndpointsOauth2ClientIdSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ServiceMonitorSpecEndpointsOauth2ClientIdSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceMonitorSpecEndpointsOauth2ClientIdSecret(obj: ServiceMonitorSpecEndpointsOauth2ClientIdSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema ServiceMonitorSpecEndpointsTlsConfigCaConfigMap
 */
export interface ServiceMonitorSpecEndpointsTlsConfigCaConfigMap {
  /**
   * The key to select.
   *
   * @schema ServiceMonitorSpecEndpointsTlsConfigCaConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ServiceMonitorSpecEndpointsTlsConfigCaConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema ServiceMonitorSpecEndpointsTlsConfigCaConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ServiceMonitorSpecEndpointsTlsConfigCaConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceMonitorSpecEndpointsTlsConfigCaConfigMap(obj: ServiceMonitorSpecEndpointsTlsConfigCaConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema ServiceMonitorSpecEndpointsTlsConfigCaSecret
 */
export interface ServiceMonitorSpecEndpointsTlsConfigCaSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ServiceMonitorSpecEndpointsTlsConfigCaSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ServiceMonitorSpecEndpointsTlsConfigCaSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ServiceMonitorSpecEndpointsTlsConfigCaSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ServiceMonitorSpecEndpointsTlsConfigCaSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceMonitorSpecEndpointsTlsConfigCaSecret(obj: ServiceMonitorSpecEndpointsTlsConfigCaSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema ServiceMonitorSpecEndpointsTlsConfigCertConfigMap
 */
export interface ServiceMonitorSpecEndpointsTlsConfigCertConfigMap {
  /**
   * The key to select.
   *
   * @schema ServiceMonitorSpecEndpointsTlsConfigCertConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ServiceMonitorSpecEndpointsTlsConfigCertConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema ServiceMonitorSpecEndpointsTlsConfigCertConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ServiceMonitorSpecEndpointsTlsConfigCertConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceMonitorSpecEndpointsTlsConfigCertConfigMap(obj: ServiceMonitorSpecEndpointsTlsConfigCertConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema ServiceMonitorSpecEndpointsTlsConfigCertSecret
 */
export interface ServiceMonitorSpecEndpointsTlsConfigCertSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ServiceMonitorSpecEndpointsTlsConfigCertSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ServiceMonitorSpecEndpointsTlsConfigCertSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ServiceMonitorSpecEndpointsTlsConfigCertSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ServiceMonitorSpecEndpointsTlsConfigCertSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceMonitorSpecEndpointsTlsConfigCertSecret(obj: ServiceMonitorSpecEndpointsTlsConfigCertSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

